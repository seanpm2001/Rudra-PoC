[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/buf/block.rs:19:1: 23:2'
source = '''
impl Drop for Alloc {
    fn drop(&mut self) {
        drop(unsafe { Vec::from_raw_parts(self.ptr, 0, self.cap) });
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/nio/sys/unix/linux.rs:102:1: 110:2'
source = '''
impl Drop for Selector {
    #[inline]
    fn drop(&mut self) {
        let res = unsafe { libc::close(self.epfd) };
        cvt(res)
            .map(drop)
            .unwrap_or_else(|e| error!("Failed to close {:?}: {}", self, e));
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/nio/sys/unix/linux.rs:157:1: 164:2'
source = '''
impl Drop for Awakener {
    fn drop(&mut self) {
        let res = unsafe { libc::close(self.event_fd) };
        cvt(res)
            .map(drop)
            .unwrap_or_else(|e| error!("Failed to close {:?}: {}", self, e));
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/channel/spsc.rs:110:1: 120:2'
source = '''
impl<T> Drop for Inner<T> {
    #[inline]
    fn drop(&mut self) {
        while let Some(t) = self.try_pop() {
            drop(t);
        }
        drop(unsafe {
            Vec::from_raw_parts(self.buf_ptr, 0, self.alloc_cap)
        });
    }
}'''
