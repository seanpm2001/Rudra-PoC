[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/handles.rs:210:1: 221:2'
source = '''
impl Drop for GcHandleList {
    fn drop(&mut self) {
        let mut bucket = self.last_bucket.load(Ordering::Acquire);
        while !bucket.is_null() {
            unsafe {
                drop(Box::from_raw(bucket));
                bucket = (*bucket).prev
                    .load(Ordering::Acquire);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/handles.rs:482:1: 525:2'
source = '''
impl<T: GcSafe> Drop for GcHandle<T> {
    fn drop(&mut self) {
        let collector = match self.collector.upgrade() {
            None => {
                /*
                 * The collector is dead.
                 * Our memory has already been freed
                 */
                return;
            },
            Some(collector) => collector,
        };
        let inner = unsafe { self.inner.as_ref() };
        debug_assert!(!inner.value
            .load(Ordering::SeqCst)
            .is_null(),
            "Pointer already invalid"
        );
        let prev = inner.refcnt
            .fetch_sub(1, Ordering::AcqRel);
        match prev {
            0 => {
                // This should be impossible.
                eprintln!("GcHandle refcnt Underflow");
                std::process::abort();
            },
            1 => {
                // Free underlying memory

            },
            _ => {}, // Other references
        }
        // Mark the value as freed
        inner.value.store(
            std::ptr::null_mut(),
            Ordering::Release
        );
        unsafe {
            collector.handle_list.append_free_slot(
                self.inner.as_ptr() as *mut HandleSlot
            );
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/context.rs:283:1: 301:2'
source = '''
impl Drop for SimpleCollectorContext {
    #[inline]
    fn drop(&mut self) {
        if self.root {
            let collector = self.collector();
            unsafe {
                trace!(
                    collector.logger, "Freeing context";
                    "ptr" => format_args!("{:p}", &**self.raw),
                    "current_thread" => FnValue(|_| ThreadId::current()),
                    "state" => ?self.raw.state.get()
                );
                collector.free_context(
                    std::ptr::read(&self.raw)
                )
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/alloc.rs:81:1: 90:2'
source = '''
impl Drop for Chunk {
    fn drop(&mut self) {
        unsafe {
            drop(Vec::from_raw_parts(
                self.start, 0,
                self.capacity()
            ))
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:887:1: 895:2'
source = '''
impl<T> Drop for BigGcObject<T> {
    fn drop(&mut self) {
        unsafe {
            if let Some(drop) = self.header.type_info.drop_func {
                drop(&mut *self.static_value as *mut T as *mut c_void);
            }
        }
    }
}'''
