[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/thread.rs:104:1: 122:2'
source = '''
impl Drop for ThreadState {
    fn drop(&mut self) {
        let mut list = self.list.lock().unwrap();

        for (tr, dtor) in list.drain() {
            unsafe {
                dtor.drop();

                // # Safety
                //
                // because storage will ensure that all tracked `ThreadsRef` are valid.
                tr.remove(self.id);
            }
        }

        THREAD_ID_POOL.lock().unwrap()
            .dealloc(self.id);
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/page.rs:139:1: 153:2'
source = '''
impl<T> Drop for Storage<T> {
    fn drop(&mut self) {
        let tr = self.as_threads_ref();

        let threads = {
            let mut threads = self.inner.threads.lock().unwrap();
            mem::take(&mut *threads)
        };
        for thread in threads.values() {
            unsafe {
                thread.release(&tr);
            }
        }
    }
}'''
