[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/wrapped_copy.rs:36:1: 74:2'
source = '''
impl Drop for WrappedCopyRequest {
    fn drop(&mut self) {
        let delete_request = DeleteObjectRequest {
            bucket: self.bucket.clone(),
            bypass_governance_retention: None, // TODO: For Object Lock
            key: self.src_key.clone(),
            mfa: None, // TODO: Required to permanently delete if MFA and versioning enabled
            request_payer: None,
            version_id: None,
        };

        // TODO: Can we avoid this clone - only used for debugging in match below
        let key = delete_request.key.clone();
        if self.verbose {
            println!("Dropping key");
            dbg!(&key);
        }

        // use spawn so we don't block
        // need reference to client
        // write handles to a FuturesUnordered - can we avoid Mutex here?
        let move_verbose = self.verbose.clone(); // wtf - this is Copy
        let move_client: Arc<S3Client> = self.client.clone();

        let handle = tokio::spawn(async move {
            match move_client.delete_object(delete_request).await {
                Ok(_) => {
                    if move_verbose {
                        println!("Deleted {}", key);
                    }
                }
                Err(x) => {
                    eprintln!("{:?}", x);
                }
            }
        });
        self.destructor_futures.lock().unwrap().push(handle);
    }
}'''
