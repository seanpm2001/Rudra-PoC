[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/glue.rs:57:1: 63:2'
source = '''
impl Drop for PicoString {
    fn drop(&mut self) {
        unsafe {
            std::alloc::dealloc(self.buf, self.mem_layout);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:144:1: 156:2'
source = '''
impl Drop for System {
    fn drop(&mut self) {
        unsafe {
            if !self.c_sys.is_null() {
                native::pico_terminate(&mut self.c_sys);
            }
            if !self.mem.is_null() {
                std::alloc::dealloc(self.mem, self.mem_layout);
                self.mem = std::ptr::null_mut();
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:189:1: 197:2'
source = '''
impl Drop for Resource {
    fn drop(&mut self) {
        unsafe {
            if !self.c_res.is_null() {
                let _ = native::pico_unloadResource(self.sys.borrow().c_sys, &mut self.c_res);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:272:1: 281:2'
source = '''
impl Drop for Voice {
    fn drop(&mut self) {
        unsafe {
            let _ = native::pico_releaseVoiceDefinition(
                self.sys.borrow().c_sys,
                self.c_name.as_ptr() as *const native::pico_Char,
            );
        }
    }
}'''
