[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/crypto/x25519/mod.rs:133:1: 138:2'
source = '''
impl Drop for X25519SecretKey {
    fn drop(&mut self) {
        // Force zero out of the memory on Drop
        unsafe { std::ptr::write_volatile(&mut self.internal, [0u8; 32]) }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/crypto/x25519/mod.rs:159:1: 164:2'
source = '''
impl Drop for X25519PublicKey {
    fn drop(&mut self) {
        // Force zero out of the memory on Drop
        unsafe { std::ptr::write_volatile(&mut self.internal, [0u8; 32]) }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/device/epoll.rs:50:1: 54:2'
source = '''
impl<H> Drop for EventPoll<H> {
    fn drop(&mut self) {
        unsafe { close(self.epoll) };
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/device/epoll.rs:350:1: 368:2'
source = '''
impl<'a, H> Drop for EventGuard<'a, H> {
    fn drop(&mut self) {
        if self.event.needs_read {
            // Must read from the event to reset it before we enable it
            let mut buf: [std::mem::MaybeUninit<u8>; 256] =
                unsafe { std::mem::MaybeUninit::uninit().assume_init() };
            while unsafe { read(self.event.fd, buf.as_mut_ptr() as _, buf.len() as _) } != -1 {}
        }

        unsafe {
            epoll_ctl(
                self.epoll,
                EPOLL_CTL_MOD,
                self.event.fd,
                &mut self.event.event,
            );
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/device/tun_linux.rs:54:1: 58:2'
source = '''
impl Drop for TunSocket {
    fn drop(&mut self) {
        unsafe { close(self.fd) };
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/device/udp_unix.rs:17:1: 21:2'
source = '''
impl Drop for UDPSocket {
    fn drop(&mut self) {
        unsafe { close(self.fd) };
    }
}'''
