[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/storage.rs:601:1: 616:2'
source = '''
impl Drop for DynamicTagSet {
    fn drop(&mut self) {
        // we own all of the vales in the set, so we need to drop and dealloc them
        for (_, meta, ptr) in self.tags.drain(..) {
            unsafe {
                let layout = std::alloc::Layout::from_size_align_unchecked(meta.size, meta.align);
                if let Some(drop_fn) = meta.drop_fn {
                    drop_fn(ptr.as_ptr());
                }
                if !meta.is_zero_sized() {
                    std::alloc::dealloc(ptr.as_ptr(), layout);
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/storage.rs:1842:1: 1871:2'
source = '''
impl Drop for ComponentStorage {
    fn drop(&mut self) {
        if let Some(ptr) = self.component_data {
            // run the drop functions of all components
            for (_, info) in unsafe { &mut *self.component_info.get() }.drain() {
                if let Some(drop_fn) = info.drop_fn {
                    let ptr = info.ptr.get_mut();
                    for i in 0..self.len() {
                        unsafe {
                            drop_fn(ptr.add(info.element_size * i));
                        }
                    }
                }
            }

            for e in &self.entities {
                self.subscribers.send(Event::EntityRemoved(*e, self.id()));
            }

            self.update_count_gauge();

            // free the chunk's memory
            if self.component_layout.size() > 0 {
                unsafe {
                    std::alloc::dealloc(ptr.as_ptr(), self.component_layout);
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/storage.rs:2254:1: 2273:2'
source = '''
impl Drop for TagStorage {
    fn drop(&mut self) {
        if self.element.size > 0 {
            let ptr = self.ptr.as_ptr();

            unsafe {
                if let Some(drop_fn) = self.element.drop_fn {
                    for i in 0..self.len {
                        drop_fn(ptr.add(i * self.element.size));
                    }
                }
                let layout = std::alloc::Layout::from_size_align_unchecked(
                    self.element.size * self.capacity,
                    self.element.align,
                );
                std::alloc::dealloc(ptr, layout);
            }
        }
    }
}'''
