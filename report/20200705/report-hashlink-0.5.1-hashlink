[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/linked_hash_map.rs:261:9: 273:10'
source = '''
impl<'a, K, V> Drop for DropFilteredValues<'a, K, V> {
            fn drop(&mut self) {
                unsafe {
                    let end_free = self.cur_free;
                    while self.cur_free != *self.free {
                        let cur_free = self.cur_free.as_ptr();
                        (*cur_free).take_entry();
                        self.cur_free = (*cur_free).links.free.next;
                    }
                    *self.free = end_free;
                }
            }
        }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/linked_hash_map.rs:550:1: 561:2'
source = '''
impl<K, V, S> Drop for LinkedHashMap<K, V, S> {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            if let Some(values) = self.values {
                drop_value_nodes(values);
                Box::from_raw(values.as_ptr());
            }
            drop_free_nodes(self.free);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/linked_hash_map.rs:1598:1: 1610:2'
source = '''
impl<K, V> Drop for IntoIter<K, V> {
    #[inline]
    fn drop(&mut self) {
        for _ in 0..self.remaining {
            unsafe {
                let tail = self.tail.as_ptr();
                self.tail = Some((*tail).links.value.prev);
                (*tail).take_entry();
                Box::from_raw(tail);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/linked_hash_map.rs:1612:1: 1624:2'
source = '''
impl<'a, K, V> Drop for Drain<'a, K, V> {
    #[inline]
    fn drop(&mut self) {
        for _ in 0..self.remaining {
            unsafe {
                let mut tail = NonNull::new_unchecked(self.tail.as_ptr());
                self.tail = Some(tail.as_ref().links.value.prev);
                tail.as_mut().take_entry();
                push_free(&mut *self.free.as_ptr(), tail);
            }
        }
    }
}'''
