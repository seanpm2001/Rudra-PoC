[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/cc.rs:453:1: 467:2'
source = '''
impl<T: ?Sized, O: AbstractObjectSpace> Drop for RawCc<T, O> {
    fn drop(&mut self) {
        let ptr: *mut RawCcBox<T, O> = self.0.as_ptr();
        // Block threaded collector. This is needed because "drop()" is a
        // complex operation. The whole operation needs to be "atomic".
        let _locked = self.inner().ref_count.locked();
        let old_ref_count = self.dec_ref();
        debug::log(|| (self.debug_name(), format!("drop ({})", self.ref_count())));
        debug_assert!(old_ref_count >= 1);
        if old_ref_count == 1 {
            // safety: CcBox lifetime maintained by ref count.
            drop_ccbox(unsafe { &mut *ptr });
        }
    }
}'''
