[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/microbench.rs:240:1: 282:2'
source = '''
impl<Config: MicroBenchConfig> Drop for PathBenchScope<Config> {
    #[inline(always)]
    fn drop(&mut self) {
        unsafe {
            let state_ptr = &mut *self.state;
            state_ptr.count = state_ptr.count.wrapping_add(1);
            if Config::TIMESTAMP_FUNC() >= state_ptr.next_print {
                print!("Path selection statistics ");
                if state_ptr.line == 0 {
                    println!("of [{}]:", state_ptr.msg);
                } else {
                    println!("at {}:{}:", state_ptr.msg, state_ptr.line);
                }
                state_ptr.branches.sort_by(|a, b| (*a).cmp(&*b).reverse());
                let mut branch_sum = 0usize;
                for b in state_ptr.branches.iter() {
                    let b_ptr = &mut **b;
                    print!("\tPath ");
                    if b_ptr.line == 0 {
                        print!("[{}]", b_ptr.msg);
                    } else {
                        print!("{}:{}", b_ptr.msg, b_ptr.line);
                    }
                    println!(
                        " {}%",
                        100.0_f64 * (b_ptr.count as f64) / (state_ptr.count as f64)
                    );
                    branch_sum = branch_sum.wrapping_add(b_ptr.count);
                    b_ptr.count = 0;
                }
                if branch_sum != state_ptr.count {
                    println!(
                        "[WARNING] Branch sum {} does not match the print interval {}",
                        branch_sum, state_ptr.count
                    );
                }

                state_ptr.count = 0;
                state_ptr.next_print = state_ptr.next_print.wrapping_add(state_ptr.print_interval);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/stable_rc.rs:146:1: 161:2'
source = '''
impl<T: ?Sized> Drop for StableArc<T> {
    #[inline]
    fn drop(&mut self) {
        unsafe {
            self.touch();

            let prev = self.ptr.as_ref().refcnt.fetch_sub(1, Ordering::Release);

            // I'm the last one decreasing the refcnt
            if prev == 1 {
                fence(Ordering::Acquire);
                drop(Box::from_raw(self.ptr.as_ptr()));
            }
        }
    }
}'''
