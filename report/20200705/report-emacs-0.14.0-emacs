[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/env.rs:85:1: 110:2'
source = '''
impl Drop for Env {
    fn drop(&mut self) {
        #[cfg(build = "debug")]
        println!("Unrooting {} values protected by {:?}", self.protected.borrow().len(), self);
        // If the `defun` returned a non-local exit, we clear it so that `free_global_ref` doesn't
        // bail out early. Afterwards we restore the non-local exit status and associated data.
        // It's kind of like an `unwind-protect`.
        let mut symbol = MaybeUninit::uninit();
        let mut data = MaybeUninit::uninit();
        // TODO: Check whether calling non_local_exit_check first makes a difference in performance.
        let status = self.non_local_exit_get(&mut symbol, &mut data);
        if status == error::SIGNAL || status == error::THROW {
            self.non_local_exit_clear();
        }
        for raw in self.protected.borrow().iter() {
            // TODO: Do we want to stop if `free_global_ref` returned a non-local exit?
            // Safety: We assume user code doesn't directly call C function `free_global_ref`.
            unsafe_raw_call_no_exit!(self, free_global_ref, *raw);
        }
        match status {
            error::SIGNAL => unsafe { self.signal(symbol.assume_init(), data.assume_init()); }
            error::THROW => unsafe { self.throw(symbol.assume_init(), data.assume_init()); }
            _ => ()
        }
    }
}'''
