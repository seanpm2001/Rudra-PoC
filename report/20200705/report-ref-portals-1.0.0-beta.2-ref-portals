[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/rc.rs:212:1: 231:2'
source = '''
impl<'a, T: ?Sized> Drop for Anchor<'a, T> {
    //TODO: Deadlock if active borrows exist.
    fn drop(&mut self) {
        unsafe {
            //SAFETY: Dropping.
            ManuallyDrop::take(&mut self.reference)
        }
        .pipe(Rc::try_unwrap)
        .unwrap_or_else(|_pointer| {
            // Immutable portals are always active borrows, so we need to deadlock immediately here,
            // since a reference could have been sent to another thread.
            error!("!Send `Anchor` dropped while at least one Portal still exists. Deadlocking thread to prevent UB.");
            let deadlock_mutex = Mutex::new(());
            let _deadlock_guard = deadlock_mutex.lock().unwrap();
            let _never = deadlock_mutex.lock();
            // Congratulations.
            unreachable!()
        });
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/rc.rs:234:1: 292:2'
source = '''
impl<'a, T: ?Sized> Drop for RwAnchor<'a, T> {
    /// Executes the destructor for this type. [Read more](https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop)
    ///
    /// # Panics
    ///
    /// If any associated `RwPortal`s exist or, otherwise, iff the anchor has been poisoned:
    ///
    /// ```rust
    /// # use assert_panic::assert_panic;
    /// use ref_portals::rc::RwAnchor;
    ///
    /// let mut x = "Scoped".to_owned();
    /// let anchor = RwAnchor::new(&mut x);
    /// let portal = anchor.portal();
    /// assert_panic!({
    ///     // Poison anchor.
    ///     let _guard = portal.borrow_mut();
    ///     panic!()
    /// });
    ///
    /// assert_panic!(
    ///     drop(anchor),
    ///     &str,
    ///     "Anchor still in use (at least one portal exists)",
    /// );
    /// ```
    fn drop(&mut self) {
        unsafe {
            //SAFETY: Dropping.
            ManuallyDrop::take(&mut self.reference)
        }
        .pipe(Rc::try_unwrap)
        .unwrap_or_else(|reference| {
            reference
                .try_borrow_mut()
                .unwrap_or_else(|_| {
                    // So at this point we know that something else has taken out a borrow of the poisonable value,
                    // and we know that that borrow will never be released because all the types leading there are `!Send`,
                    // and we also don't know whether that's only used on this one thread because a derived reference could have been sent elsewhere.
                    // Meaning this is the only way to prevent UB here:
                    error!("!Send `RwAnchor` dropped while borrowed from. Deadlocking thread to prevent UB.");
                    let deadlock_mutex = Mutex::new(());
                    let _deadlock_guard = deadlock_mutex.lock().unwrap();
                    let _never = deadlock_mutex.lock();
                    // Congratulations.
                    unreachable!()
                })
                .poisoned = true;
            panic!(ANCHOR_STILL_IN_USE)
        })
        .into_inner() // Not fallible.
        .poisoned
        .pipe(|poisoned| {
            if poisoned {
                panic!(ANCHOR_POISONED)
            }
        })
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/sync.rs:255:1: 284:2'
source = '''
impl<'a, T: ?Sized> Drop for Anchor<'a, T> {
    /// Executes the destructor for this type. [Read more](https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop)
    ///
    /// # Panics
    ///
    /// If any associated `Portal`s exist:
    ///
    /// ```rust
    /// # use assert_panic::assert_panic;
    /// use ref_portals::sync::Anchor;
    ///
    /// let x = "Scoped".to_owned();
    /// let anchor = Anchor::new(&x);
    /// let portal = anchor.portal();
    ///
    /// assert_panic!(
    ///     drop(anchor),
    ///     &str,
    ///     "Anchor still in use (at least one portal exists)",
    /// );
    /// ```
    fn drop(&mut self) {
        unsafe {
            //SAFETY: Dropping.
            ManuallyDrop::take(&mut self.reference)
        }
        .pipe(Arc::try_unwrap)
        .unwrap_or_else(|_| panic!(ANCHOR_STILL_IN_USE));
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/sync.rs:286:1: 326:2'
source = '''
impl<'a, T: ?Sized> Drop for RwAnchor<'a, T> {
    /// Executes the destructor for this type. [Read more](https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop)
    ///
    /// # Panics
    ///
    /// If any associated `RwPortal`s exist or, otherwise, iff the anchor has been poisoned:
    ///
    /// ```rust
    /// # use assert_panic::assert_panic;
    /// use ref_portals::sync::RwAnchor;
    ///
    /// let mut x = "Scoped".to_owned();
    /// let anchor = RwAnchor::new(&mut x);
    /// let portal = anchor.portal();
    /// assert_panic!({
    ///     // Poison anchor.
    ///     let _guard = portal.write();
    ///     panic!()
    /// });
    ///
    /// assert_panic!(
    ///     drop(anchor),
    ///     &str,
    ///     "Anchor still in use (at least one portal exists)",
    /// );
    /// ```
    fn drop(&mut self) {
        unsafe {
            //SAFETY: Dropping.
            ManuallyDrop::take(&mut self.reference)
        }
        .pipe(Arc::try_unwrap)
        .unwrap_or_else(|reference| {
            // Poison RwLock.
            let _guard = reference.write();
            panic!(ANCHOR_STILL_IN_USE);
        })
        .into_inner()
        .unwrap_or_else(|error| Err(error).expect(ANCHOR_POISONED));
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/sync.rs:328:1: 368:2'
source = '''
impl<'a, T: ?Sized> Drop for WAnchor<'a, T> {
    /// Executes the destructor for this type. [Read more](https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop)
    ///
    /// # Panics
    ///
    /// If any associated `WPortal`s exist or, otherwise, iff the anchor has been poisoned:
    ///
    /// ```rust
    /// # use assert_panic::assert_panic;
    /// use ref_portals::sync::WAnchor;
    ///
    /// let mut x = "Scoped".to_owned();
    /// let anchor = WAnchor::new(&mut x);
    /// let portal = anchor.portal();
    /// assert_panic!({
    ///     // Poison anchor.
    ///     let _guard = portal.lock();
    ///     panic!()
    /// });
    ///
    /// assert_panic!(
    ///     drop(anchor),
    ///     &str,
    ///     "Anchor still in use (at least one portal exists)",
    /// );
    /// ```
    fn drop(&mut self) {
        unsafe {
            //SAFETY: Dropping.
            ManuallyDrop::take(&mut self.reference)
        }
        .pipe(Arc::try_unwrap)
        .unwrap_or_else(|reference| {
            // Poison Mutex.
            let _guard = reference.lock();
            panic!(ANCHOR_STILL_IN_USE);
        })
        .into_inner()
        .unwrap_or_else(|error| Err(error).expect(ANCHOR_POISONED));
    }
}'''
