[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/sys/epoll.rs:125:1: 131:2'
source = '''
impl Drop for Epoll {
    fn drop(&mut self) {
        unsafe {
            let _ = libc::close(self.epfd);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/plus/mpsc_queue.rs:105:1: 116:2'
source = '''
impl<T> Drop for Queue<T> {
    fn drop(&mut self) {
        unsafe {
            let mut cur = *self.tail.get();
            while !cur.is_null() {
                let next = (*cur).next.load(Ordering::Relaxed);
                let _: Box<Node<T>> = Box::from_raw(cur);
                cur = next;
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/plus/spsc_queue.rs:244:1: 255:2'
source = '''
impl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition, ConsumerAddition> {
    fn drop(&mut self) {
        unsafe {
            let mut cur = *self.producer.first.get();
            while !cur.is_null() {
                let next = (*cur).next.load(Ordering::Relaxed);
                let _n: Box<Node<T>> = Box::from_raw(cur);
                cur = next;
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/plus/lru_cache.rs:307:1: 317:2'
source = '''
impl<K, V> Drop for LruCache<K, V> {
    fn drop(&mut self) {
        unsafe {
            // Prevent compiler from trying to drop the un-initialized field in the sigil node.
            let node: Box<LruEntry<K, V>> = mem::transmute(self.head);
            let LruEntry { key: k, value: v, .. } = *node;
            mem::forget(k);
            mem::forget(v);
        }
    }
}'''
