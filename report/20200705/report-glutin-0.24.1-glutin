[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/api/egl/make_current_guard.rs:81:1: 113:2'
source = '''
impl Drop for MakeCurrentGuard {
    fn drop(&mut self) {
        let egl = super::EGL.as_ref().unwrap();
        let (draw_surface, read_surface, context) =
            match self.possibly_invalid.take() {
                Some(inner) => (
                    inner.old_draw_surface,
                    inner.old_read_surface,
                    inner.old_context,
                ),
                None => (
                    ffi::egl::NO_SURFACE,
                    ffi::egl::NO_SURFACE,
                    ffi::egl::NO_CONTEXT,
                ),
            };

        let display = match self.old_display {
            ffi::egl::NO_DISPLAY => self.display,
            old_display => old_display,
        };

        unsafe {
            let res =
                egl.MakeCurrent(display, draw_surface, read_surface, context);

            if res == 0 {
                let err = egl.GetError();
                panic!("`eglMakeCurrent` failed: 0x{:x}", err)
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/api/egl/mod.rs:752:1: 845:2'
source = '''
impl Drop for Context {
    fn drop(&mut self) {
        unsafe {
            // https://stackoverflow.com/questions/54402688/recreate-eglcreatewindowsurface-with-same-native-window
            let egl = EGL.as_ref().unwrap();
            let surface = self
                .surface
                .as_ref()
                .map(|s| *s.lock())
                .unwrap_or(ffi::egl::NO_SURFACE);
            // Ok, so we got to call `glFinish` before destroying the context
            // to ensure it actually gets destroyed. This requires making the
            // this context current.
            let mut guard = MakeCurrentGuard::new(
                self.display,
                surface,
                surface,
                self.context,
            )
            .map_err(|err| ContextError::OsError(err))
            .unwrap();

            guard.if_any_same_then_invalidate(surface, surface, self.context);

            let gl_finish_fn = self.get_proc_address("glFinish");
            assert!(gl_finish_fn != std::ptr::null());
            let gl_finish_fn =
                std::mem::transmute::<_, extern "system" fn()>(gl_finish_fn);
            gl_finish_fn();

            egl.DestroyContext(self.display, self.context);
            self.context = ffi::egl::NO_CONTEXT;
            egl.DestroySurface(self.display, surface);
            if let Some(ref surface) = self.surface {
                let mut surface = surface.lock();
                *surface = ffi::egl::NO_SURFACE;
            }

            // In a reasonable world, we could uncomment the line bellow.
            //
            // This is no such world. Lets talk about something.
            //
            // You see, every call to `get_native_display` returns the exact
            // same display, just look at the docs:
            //
            // "Multiple calls made to eglGetDisplay with the same display_id
            // will return the same EGLDisplay handle."
            //
            // My EGL implementation does not do any ref counting, nor do the
            // EGL docs mention ref counting anywhere. In fact, the docs state
            // that there will be *no effect*, which, in a way, implies no ref
            // counting:
            //
            // "Initializing an already initialized EGL display connection has
            // no effect besides returning the version numbers."
            //
            // So, if we terminate the display, other people who are using it
            // won't be so happy.
            //
            // Well, how did I stumble on this issue you might ask...
            //
            // In this case, the "other people" was us, for it appears my EGL
            // implementation does not follow the docs,  or maybe I'm misreading
            // them. You see, according to the egl docs:
            //
            // "To release the current context without assigning a new one, set
            // context to EGL_NO_CONTEXT and set draw and read to
            // EGL_NO_SURFACE.  [...] ******This is the only case where an
            // uninitialized display may be passed to eglMakeCurrent.******"
            // (Emphasis mine).
            //
            // Well, my computer returns EGL_BAD_DISPLAY if the display passed
            // to eglMakeCurrent is uninitialized, which allowed to me to spot
            // this issue.
            //
            // I would have assumed that if EGL was going to provide us with
            // the same EGLDisplay that they'd at least do
            // some ref counting, but they don't.
            //
            // FIXME: Technically we are leaking resources, not much we can do.
            // Yeah, we could have a global static that does ref counting
            // ourselves, but what if some other library is using the display.
            //
            // On unix operating systems, we could preload a little lib that
            // does ref counting on that level, but:
            //      A) What about other platforms?
            //      B) Do you *really* want all glutin programs to preload a
            //      library?
            //      C) Who the hell is going to maintain that?
            //
            // egl.Terminate(self.display);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/api/glx/make_current_guard.rs:62:1: 83:2'
source = '''
impl Drop for MakeCurrentGuard {
    fn drop(&mut self) {
        let glx = super::GLX.as_ref().unwrap();
        let (drawable, context) = match self.possibly_invalid.take() {
            Some(inner) => (inner.old_drawable, inner.old_context),
            None => (0, std::ptr::null()),
        };

        let display = match self.old_display {
            old_display if old_display == std::ptr::null_mut() => self.display,
            old_display => old_display,
        };

        let res =
            unsafe { glx.MakeCurrent(display as *mut _, drawable, context) };

        if res == 0 {
            let err = self.xconn.check_errors();
            panic!("`glXMakeCurrent` failed: {:?}", err);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/api/glx/mod.rs:227:1: 251:2'
source = '''
impl Drop for Context {
    fn drop(&mut self) {
        let glx = GLX.as_ref().unwrap();
        unsafe {
            // See `drop` for `crate::api::egl::Context` for rationale.
            let mut guard =
                MakeCurrentGuard::new(&self.xconn, self.drawable, self.context)
                    .map_err(|err| ContextError::OsError(err))
                    .unwrap();

            let gl_finish_fn = self.get_proc_address("glFinish");
            assert!(gl_finish_fn != std::ptr::null());
            let gl_finish_fn =
                std::mem::transmute::<_, extern "system" fn()>(gl_finish_fn);
            gl_finish_fn();

            if guard.old_context() == Some(self.context) {
                guard.invalidate()
            }
            std::mem::drop(guard);

            glx.DestroyContext(self.xconn.display as *mut _, self.context);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/api/osmesa/mod.rs:235:1: 240:2'
source = '''
impl Drop for OsMesaContext {
    #[inline]
    fn drop(&mut self) {
        unsafe { osmesa_sys::OSMesaDestroyContext(self.context) }
    }
}'''
