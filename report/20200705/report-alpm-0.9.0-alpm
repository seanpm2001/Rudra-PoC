[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/alpm.rs:29:1: 37:2'
source = '''
impl Drop for Alpm {
    fn drop(&mut self) {
        if self.drop {
            // alpm should do this for us, but is bugged
            unsafe { alpm_trans_release(self.handle) };
            unsafe { alpm_release(self.handle) };
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/be_pkg.rs:13:1: 19:2'
source = '''
impl<'a> Drop for LoadedPackage<'a> {
    fn drop(&mut self) {
        unsafe {
            alpm_pkg_free(self.pkg.pkg);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/conflict.rs:16:1: 22:2'
source = '''
impl Drop for Conflict {
    fn drop(&mut self) {
        if self.drop {
            unsafe { alpm_conflict_free(self.inner) }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/deps.rs:20:1: 26:2'
source = '''
impl<'a> Drop for Depend<'a> {
    fn drop(&mut self) {
        if self.drop {
            unsafe { alpm_dep_free(self.inner) }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/deps.rs:160:1: 164:2'
source = '''
impl Drop for DepMissing {
    fn drop(&mut self) {
        unsafe { alpm_depmissing_free(self.inner) }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/list.rs:198:1: 223:2'
source = '''
impl<'a, T> Drop for AlpmList<'a, T> {
    fn drop(&mut self) {
        match self.free {
            FreeMethod::None => {}
            FreeMethod::FreeList => {
                unsafe { alpm_list_free(self.list) };
            }
            FreeMethod::FreeInner => {
                unsafe { alpm_list_free_inner(self.list, Some(free)) };
                unsafe { alpm_list_free(self.list) };
            }
            FreeMethod::FreeConflict => {
                unsafe { alpm_list_free_inner(self.list, Some(conflict_free)) };
                unsafe { alpm_list_free(self.current) };
            }
            FreeMethod::FreeFileConflict => {
                unsafe { alpm_list_free_inner(self.list, Some(fileconflict_free)) };
                unsafe { alpm_list_free(self.current) };
            }
            FreeMethod::FreeDepMissing => {
                unsafe { alpm_list_free_inner(self.list, Some(depmissing_free)) };
                unsafe { alpm_list_free(self.current) };
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/signing.rs:119:1: 123:2'
source = '''
impl Drop for SigList {
    fn drop(&mut self) {
        unsafe { alpm_siglist_cleanup(&mut self.inner) };
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/types.rs:946:1: 950:2'
source = '''
impl<'a> Drop for ChangeLog<'a> {
    fn drop(&mut self) {
        unsafe { alpm_pkg_changelog_close(self.pkg.pkg, self.stream) };
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/types.rs:988:1: 992:2'
source = '''
impl Drop for FileConflict {
    fn drop(&mut self) {
        unsafe { alpm_fileconflict_free(self.inner) }
    }
}'''
