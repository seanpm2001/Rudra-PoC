[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:303:5: 319:6'
source = '''
impl Drop for AutoGcSpace {
        fn drop(&mut self) {
            let this: NonNull<Self> = unsafe { NonNull::new_unchecked(self) };
            let mut locked_self = self.lock();
            locked_self.state = AutoGcSpaceState::Mark {
                marked: HashSet::new(),
                marking_gc: BTreeSet::new(),
                marking_root: BTreeSet::new(),
            };
            for x in locked_self.elements.drain() {
                unsafe {
                    debug_assert_eq!(*x.get_space_nonnull_mutex().as_ref().lock(), this);
                    x.destory();
                }
            }
        }
    }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:676:5: 686:6'
source = '''
impl<T: Trace> Drop for Root<T> {
        fn drop(&mut self) {
            unsafe {
                let space_ref_locked = self.ptr.as_ref().space.lock();
                AutoGcSpace::remove_root_and_destory_if_empty(
                    *space_ref_locked,
                    &HashableAnyRoot(self.clone_as_any()),
                );
            }
        }
    }'''
