[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/context.rs:682:1: 689:2'
source = '''
impl<'a> Drop for Context<'a> {
    fn drop(&mut self) {
        unsafe {
            // This also disconnects if necessary.
            raw::soundio_destroy(self.soundio);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/device.rs:482:1: 488:2'
source = '''
impl<'a> Drop for Device<'a> {
    fn drop(&mut self) {
        unsafe {
            raw::soundio_device_unref(self.device);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/instream.rs:83:1: 89:2'
source = '''
impl<'a> Drop for InStreamUserData<'a> {
    fn drop(&mut self) {
        unsafe {
            raw::soundio_instream_destroy(self.instream);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/instream.rs:408:1: 426:2'
source = '''
impl<'a> Drop for InStreamReader<'a> {
    /// This will drop all of the frames from when you called `begin_read()`.
    ///
    /// Errors are currently are just printed to the console and ignored.
    ///
    /// # Errors
    ///
    /// * `Error::Streaming`
    fn drop(&mut self) {
        if self.read_started {
            unsafe {
                match raw::soundio_instream_end_read(self.instream) {
                    0 => {}
                    x => println!("Error reading instream: {}", Error::from(x)),
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/outstream.rs:83:1: 89:2'
source = '''
impl<'a> Drop for OutStreamUserData<'a> {
    fn drop(&mut self) {
        unsafe {
            raw::soundio_outstream_destroy(self.outstream);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/outstream.rs:466:1: 484:2'
source = '''
impl<'a> Drop for OutStreamWriter<'a> {
    /// This will drop all of the frames from when you called `begin_write()`.
    ///
    /// Errors are currently are just printed to the console and ignored.
    ///
    /// # Errors
    ///
    /// * `Error::Streaming`
    fn drop(&mut self) {
        if self.write_started {
            unsafe {
                match raw::soundio_outstream_end_write(self.outstream) {
                    0 => {}
                    x => println!("Error writing outstream: {}", Error::from(x)),
                }
            }
        }
    }
}'''
