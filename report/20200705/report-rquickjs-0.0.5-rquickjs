[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/context/mod.rs:129:1: 144:2'
source = '''
impl Drop for Context {
    fn drop(&mut self) {
        //TODO
        let guard = match self.rt.try_lock() {
            Some(x) => x,
            // When we can not enter the runtime lock we
            // prefer to leak the value over possibly corrupting memory
            // with a double free
            _ => return,
        };
        self.reset_stack();
        unsafe { qjs::JS_FreeContext(self.ctx) }
        // Explicitly drop the guard to ensure it is valid during the entire use of runtime
        mem::drop(guard)
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/runtime.rs:138:1: 146:2'
source = '''
impl Drop for Inner {
    fn drop(&mut self) {
        unsafe {
            let ptr = qjs::JS_GetRuntimeOpaque(self.rt);
            let _opaque: Box<Opaque> = Box::from_raw(ptr as *mut _);
            qjs::JS_FreeRuntime(self.rt)
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/value/string.rs:18:9: 24:10'
source = '''
impl<'js> Drop for DropStr<'js> {
            fn drop(&mut self) {
                unsafe {
                    qjs::JS_FreeCString(self.0.ctx, self.1);
                }
            }
        }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/value/atom.rs:60:9: 66:10'
source = '''
impl<'js> Drop for DropStr<'js> {
            fn drop(&mut self) {
                unsafe {
                    qjs::JS_FreeCString(self.0.ctx, self.1);
                }
            }
        }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/value/atom.rs:115:1: 121:2'
source = '''
impl<'js> Drop for Atom<'js> {
    fn drop(&mut self) {
        unsafe {
            qjs::JS_FreeAtom(self.ctx.ctx, self.atom);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/value/rf.rs:89:1: 100:2'
source = '''
impl<Ty: JsRefType> Drop for JsRef<'_, Ty> {
    fn drop(&mut self) {
        unsafe {
            let p = self.ptr as *mut qjs::JSRefCountHeader;
            (*p).ref_count -= 1;
            if (*p).ref_count <= 0 {
                let v = self.as_js_value();
                qjs::__JS_FreeValue(self.ctx.ctx, v);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/value/multi.rs:45:1: 57:2'
source = '''
impl<'js> Drop for ValueIter<'js> {
    fn drop(&mut self) {
        unsafe {
            if self.value.ownership {
                self.current += 1;
                for v in self.current..self.value.len {
                    let ptr = self.value.ptr.add(v);
                    Value::from_js_value(self.value.ctx, *ptr).ok();
                }
            }
        }
    }
}'''
