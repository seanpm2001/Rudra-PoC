[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/local.rs:225:1: 244:2'
source = '''
impl Drop for LocalInner {
    #[inline]
    fn drop(&mut self) {
        for hazard in &self.hazard_cache {
            hazard.set_free(sanitize::RELAXED_STORE);
        }

        // (LOC:3) this `Release` fence synchronizes-with the `SeqCst` fence (LOC:2) but WITHOUT
        // enforcing a total order
        atomic::fence(Release);

        let _ = self.scan_hazards();
        // this is safe because the field is neither accessed afterwards nor dropped
        let bag = unsafe { ptr::read(&*self.retired_bag) };

        if !bag.inner.is_empty() {
            GLOBAL.abandon_retired_bag(bag);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/retired.rs:108:1: 116:2'
source = '''
impl Drop for ReclaimOnDrop {
    #[inline]
    fn drop(&mut self) {
        // this is safe because it is guaranteed that even in case of a panic,
        // retired records are only ever dropped during the course of
        // `LocalInner::scan_hazards`.
        unsafe { self.0.reclaim() };
    }
}'''
