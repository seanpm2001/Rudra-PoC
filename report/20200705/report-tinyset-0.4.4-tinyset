[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/setu32b.rs:791:1: 803:2'
source = '''
impl Drop for SetU32 {
    fn drop(&mut self) {
        if unsafe { self.0.tiny != 0 && self.0.tiny & 3 != 1 } {
            let n = self.num_u32();
            if n != 0 {
                unsafe {
                    let ptr = (self.0.tiny & !3) as *mut u8;
                    std::alloc::dealloc(ptr, layout_for_num_u32(n));
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/setu32.rs:1320:1: 1333:2'
source = '''
impl Drop for SetU32 {
    fn drop(&mut self) {
        if self.0 as usize > 0 {
            // make it drop by moving it out
            let c = self.capacity();
            if c == 0 {
            } else {
                unsafe {
                    std::alloc::dealloc(self.0 as *mut u8, layout_for_capacity(c));
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/setu64.rs:1289:1: 1302:2'
source = '''
impl Drop for SetU64 {
    fn drop(&mut self) {
        if self.0 as usize > 0 {
            // make it drop by moving it out
            let c = self.capacity();
            if c == 0 {
            } else {
                unsafe {
                    std::alloc::dealloc(self.0 as *mut u8, layout_for_capacity(c));
                }
            }
        }
    }
}'''
