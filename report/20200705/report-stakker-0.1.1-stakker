[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/rc/minrc.rs:74:1: 94:2'
source = '''
impl<T: ?Sized> Drop for MinRc<T> {
    fn drop(&mut self) {
        // Locks on max value.  So this leaks the memory, which is
        // safe.  This can only happen if someone has already leaked
        // ~2**64 references to this instance (on 64-bit).
        let rcbox = self.rcbox();
        let (count, went_to_zero) = match rcbox.count.get() {
            1 => (0, true),
            0 => (0, false),
            std::usize::MAX => (std::usize::MAX, false),
            v => (v - 1, false),
        };
        rcbox.count.replace(count);

        if went_to_zero {
            // Safe because we drop this just once, when the final
            // reference is released
            unsafe { drop(Box::from_raw(self.ptr.as_mut())) }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/queue/flat.rs:95:1: 99:2'
source = '''
impl<S> Drop for FnOnceQueue<S> {
    fn drop(&mut self) {
        self.drain_for_each(|ptr| unsafe { (&mut *ptr).drop() });
    }
}'''
