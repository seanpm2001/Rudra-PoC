[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/divbuf.rs:302:1: 316:2'
source = '''
impl Drop for DivBufShared {
    fn drop(&mut self) {
        let inner = unsafe { &*self.inner };
        if inner.sharers.fetch_sub(1, Release) == 1 {
            if inner.accessors.load(Relaxed) == 0 {
                // See the comments in std::sync::Arc::drop for why the fence is
                // required.
                atomic::fence(Acquire);
                unsafe {
                    Box::from_raw(self.inner);
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/divbuf.rs:590:1: 602:2'
source = '''
impl Drop for DivBuf {
    fn drop(&mut self) {
        let inner = unsafe { &*self.inner };
        if inner.accessors.fetch_sub(1, Release) == 1 {
            if inner.sharers.load(Relaxed) == 0 {
                atomic::fence(Acquire);
                unsafe {
                    Box::from_raw(self.inner);
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/divbuf.rs:961:1: 973:2'
source = '''
impl Drop for DivBufMut {
    fn drop(&mut self) {
        let inner = unsafe { &*self.inner };
        if inner.accessors.fetch_sub(ONE_WRITER, Release) == ONE_WRITER {
            if inner.sharers.load(Relaxed) == 0 {
                atomic::fence(Acquire);
                unsafe {
                    Box::from_raw(self.inner);
                }
            }
        }
    }
}'''
