[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/read.rs:90:1: 99:2'
source = '''
impl<T> Drop for ReadHandle<T> {
    fn drop(&mut self) {
        if let Some(inner) = self.inner.take() {
            if Arc::strong_count(&inner) == 1 {
                let readers_inner = inner.swap(ptr::null_mut(), Ordering::Relaxed);
                mem::drop(unsafe { Box::from_raw(readers_inner) });
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/write.rs:119:1: 134:2'
source = '''
impl<T: OperationCache> Drop for WriteHandle<T> {
    fn drop(&mut self) {
        if self.writers_inner.is_some() {
            if !self.ops.is_empty() {
                self.refresh();
            }
            assert!(self.ops.is_empty());

            let writers_inner = self.writers_inner.as_ref().unwrap().swap(ptr::null_mut(), Ordering::Relaxed);
            mem::drop(unsafe { Box::from_raw(writers_inner) });
        }

        // The readers should be able to continue reading after this writer has gone, and thus they
        // should be responsible for destroying their handle.
    }
}'''
