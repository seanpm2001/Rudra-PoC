[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/par/table.rs:423:1: 432:2'
source = '''
impl<'a, K: 'a, V: 'a> Drop for ParIntoIterProducer<'a, K, V> {
    fn drop(&mut self) {
        while let Some(bucket) = self.iter.next() {
            unsafe {
                bucket.set_empty();
                ptr::drop_in_place(bucket.pair());
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/std_hash/table.rs:1124:1: 1150:2'
source = '''
impl<K, V> Drop for RawTable<K, V> {
    fn drop(&mut self) {
        if self.capacity() == 0 {
            return;
        }

        // This is done in reverse because we've likely partially taken
        // some elements out with `.into_iter()` from the front.
        // Check if the size is 0, so we don't do a useless scan when
        // dropping empty tables such as on resize.
        // Also avoid double drop of elements that have been already moved out.
        unsafe {
            if needs_drop::<(K, V)>() {
                // avoid linear runtime for types that don't need drop
                self.rev_drop_buckets();
            }
        }

        let (layout, _) = calculate_layout::<K, V>(self.capacity())
            .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });
        unsafe {
            dealloc(NonNull::new_unchecked(self.hashes.ptr()).cast().as_ptr(), layout);
            // Remember how everything was allocated out of one buffer
            // during initialization? We only need one call to free here.
        }
    }
}'''
