[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/agent.rs:126:1: 130:2'
source = '''
impl Drop for Agent {
    fn drop(&mut self) {
        unsafe { raw::libssh2_agent_free(self.raw) }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/channel.rs:488:1: 494:2'
source = '''
impl Drop for ChannelInner {
    fn drop(&mut self) {
        unsafe {
            let _ = raw::libssh2_channel_free(self.unsafe_raw);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/knownhosts.rs:281:1: 286:2'
source = '''
impl Drop for KnownHosts {
    fn drop(&mut self) {
        let _sess = self.sess.lock();
        unsafe { raw::libssh2_knownhost_free(self.raw) }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/listener.rs:47:1: 54:2'
source = '''
impl Drop for Listener {
    fn drop(&mut self) {
        let _sess = self.sess.lock();
        unsafe {
            let _ = raw::libssh2_channel_forward_cancel(self.raw);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/session.rs:1054:1: 1060:2'
source = '''
impl Drop for SessionInner {
    fn drop(&mut self) {
        unsafe {
            let _rc = raw::libssh2_session_free(self.raw);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/sftp.rs:428:1: 441:2'
source = '''
impl Drop for Sftp {
    fn drop(&mut self) {
        // Set ssh2 to blocking if sftp was not shutdown yet.
        if let Some(inner) = self.inner.take() {
            let sess = inner.sess.lock();
            let was_blocking = sess.is_blocking();
            sess.set_blocking(true);
            // The shutdown statement can go wrong and return an error code, but we are too late 
            // in the execution to recover it.
            let _shutdown_result = unsafe { raw::libssh2_sftp_shutdown(inner.raw) };
            sess.set_blocking(was_blocking);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/sftp.rs:640:1: 653:2'
source = '''
impl Drop for File {
    fn drop(&mut self) {
        // Set ssh2 to blocking if the file was not closed yet.
        if let Some(file_inner) = self.inner.take() {
            let sess_inner = file_inner.sftp.sess.lock();
            let was_blocking = sess_inner.is_blocking();
            sess_inner.set_blocking(true);
            // The close statement can go wrong and return an error code, but we are too late 
            // in the execution to recover it.
            let _close_handle_result = unsafe { raw::libssh2_sftp_close_handle(file_inner.raw) };
            sess_inner.set_blocking(was_blocking);
        }
    }
}'''
