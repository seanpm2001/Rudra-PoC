[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/user_data.rs:74:1: 86:2'
source = '''
impl Drop for UserData {
    fn drop(&mut self) {
        // only drop non-Send user data if we are on the right thread, leak it otherwise
        if let Some(&mut UserDataInner::NonThreadSafe(ref mut val, threadid)) = self.inner.get_mut()
        {
            if threadid == thread::current().id() {
                unsafe {
                    ManuallyDrop::drop(&mut **val);
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/user_data.rs:264:5: 268:6'
source = '''
impl<T> Drop for AppendList<T> {
        fn drop(&mut self) {
            unsafe { Self::node_from_raw(mem::replace(self.0.get_mut(), ptr::null_mut())) };
        }
    }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lib.rs:209:1: 217:2'
source = '''
impl<T: ?Sized> Drop for ThreadGuard<T> {
    fn drop(&mut self) {
        // We can only actually perform the drop if we are on the right thread
        // otherwise it may be racy, so we just leak the value
        if self.thread == ::std::thread::current().id() {
            unsafe { std::mem::ManuallyDrop::drop(&mut self.val) }
        }
    }
}'''
