[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/handle.rs:55:1: 64:2'
source = '''
impl<T: HandleType> Drop for Handle<T> {
    fn drop(&mut self) {
        let ptr = self.ptr.get();
        if !ptr.is_null() {
            unsafe {
                OCIHandleFree(ptr as *mut c_void, (*ptr).get_type());
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/desc.rs:57:1: 66:2'
source = '''
impl<T: DescriptorType> Drop for Descriptor<T> {
    fn drop(&mut self) {
        let ptr = self.ptr.get();
        if !ptr.is_null() {
            unsafe {
                OCIDescriptorFree(ptr as *mut c_void, self.get_type());
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/conn.rs:114:1: 128:2'
source = '''
impl Drop for Connection<'_> {
    fn drop(&mut self) {
        if let ConnState::Session = self.state {
            unsafe {
                OCISessionEnd(self.svc_ptr(), self.err_ptr(), self.usr_ptr(), OCI_DEFAULT);
            }
            self.state = ConnState::Attached;
        }
        if let ConnState::Attached = self.state {
            unsafe {
                OCIServerDetach(self.srv.get(), self.err_ptr(), OCI_DEFAULT);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/stmt.rs:357:1: 371:2'
source = '''
impl Drop for Statement<'_> {
    fn drop(&mut self) {
        let env = self.env_ptr();
        let err = self.err_ptr();
        let cols = self.cols.get_mut();
        while let Some( mut col ) = cols.pop() {
            col.drop_output(env, err);
        }
        if !self.stmt.is_null() {
            unsafe {
                OCIStmtRelease(self.stmt, self.err_ptr(), ptr::null(), 0, OCI_DEFAULT);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/lob.rs:339:1: 364:2'
source = '''
impl<'a,T> Drop for LOB<'a,T>
    where T: DescriptorType<OCIType=OCILobLocator>
{
    fn drop(&mut self) {
        let mut is_open: u8;
        let res = unsafe {
            is_open = mem::uninitialized();
            OCILobIsOpen(self.conn.svc_ptr(), self.conn.err_ptr(), self.as_mut_ptr(), &mut is_open)
        };
        if res == OCI_SUCCESS && is_open != 0 {
            unsafe {
                OCILobClose(self.conn.svc_ptr(), self.conn.err_ptr(), self.as_mut_ptr());
            }
        }
        let mut is_temp: u8;
        let res = unsafe {
            is_temp = mem::uninitialized();
            OCILobIsTemporary(self.conn.svc_ptr(), self.conn.err_ptr(), self.as_mut_ptr(), &mut is_temp)
        };
        if res == OCI_SUCCESS && is_temp != 0 {
            unsafe {
                OCILobFreeTemporary(self.conn.svc_ptr(), self.conn.err_ptr(), self.as_mut_ptr());
            }
        }
    }
}'''
