[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/gc/mutex.rs:170:1: 182:2'
source = '''
impl<'a, T> Drop for MutexGuard<'a, T>
where
    T: ?Sized + Trace,
{
    fn drop(&mut self) {
        let rooted = self.rooted.lock().unwrap();
        if !*rooted {
            unsafe {
                self.value.unroot();
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/gc.rs:386:1: 401:2'
source = '''
impl Drop for AllocPtr {
    fn drop(&mut self) {
        unsafe {
            // Avoid stack overflow by looping through all next pointers instead of doing it
            // recursively
            let mut current = self.next.take();
            while let Some(mut next) = current {
                current = next.next.take();
            }
            let size = self.size();
            ((*self.type_info).drop)(self.value());
            ptr::read(&*self.ptr);
            deallocate(self.ptr as *mut u8, size);
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/core/mod.rs:681:13: 690:14'
source = '''
impl<U: Default> Drop for FillRemainingOnDrop<U> {
                fn drop(&mut self) {
                    unsafe {
                        while self.ptr != self.end {
                            ptr::write(self.ptr, U::default());
                            self.ptr = self.ptr.add(1);
                        }
                    }
                }
            }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/stack.rs:378:1: 387:2'
source = '''
impl<S> Drop for FrameViewMut<'_, S>
where
    S: StackState,
{
    fn drop(&mut self) {
        unsafe {
            *self.stack.frames.last_mut().unwrap() = self.frame.to_state().unrooted();
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/thread.rs:575:1: 599:2'
source = '''
impl Drop for Thread {
    fn drop(&mut self) {
        // The child threads need to refer to `self` so drop the gc (and thus the child threads)
        // first so that `self` is valid while dropping them
        let context = self.context.get_mut().unwrap_or_else(|err| {
            // Ignore poisoning since we don't need to interact with the Gc values, only
            // drop them
            err.into_inner()
        });
        let mut gc_to_drop =
            ::std::mem::replace(&mut context.gc, Gc::new(Generation::default(), 0));
        // Make sure that the RefMut is dropped before the Gc itself as the RwLock is dropped
        // when the Gc is dropped
        drop(context);

        // SAFETY GcPtr's may not leak outside of the `Thread` so we can safely clear it when
        // droppting the thread
        unsafe {
            gc_to_drop.clear();
        }

        let mut parent_threads = self.parent_threads();
        parent_threads.remove(self.thread_index);
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/thread.rs:601:1: 626:2'
source = '''
impl Drop for RootedThread {
    fn drop(&mut self) {
        if self.rooted && self.unroot_() {
            // The last RootedThread was dropped, there is no way to refer to the global state any
            // longer so drop everything
            let mut gc_ref = self.thread.global_state.gc.lock().unwrap_or_else(|err| {
                // Ignore poisoning since we don't need to interact with the Gc values, only
                // drop them
                err.into_inner()
            });
            let mut gc_to_drop = std::mem::replace(&mut *gc_ref, Gc::new(Generation::default(), 0));
            // Make sure that the RefMut is dropped before the Gc itself as the RwLock is dropped
            // when the Gc is dropped
            drop(gc_ref);

            // Macros can contain unrooted thread references via the database so we must drop those first
            self.global_state.get_macros().clear();

            // SAFETY GcPtr's may not leak outside of the `Thread` so we can safely clear it when
            // droppting the thread
            unsafe {
                gc_to_drop.clear();
            }
        }
    }
}'''
