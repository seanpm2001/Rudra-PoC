[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/alc.rs:483:1: 487:2'
source = '''
impl Drop for DeviceInner {
	fn drop(&mut self) {
		unsafe { self.alto.0.api.alcCloseDevice(self.dev); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/alc.rs:801:1: 805:2'
source = '''
impl<F: StandardFrame> Drop for Capture<F> {
	fn drop(&mut self) {
		unsafe { self.alto.0.api.alcCaptureCloseDevice(self.dev); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/al/mod.rs:672:1: 677:2'
source = '''
impl Drop for ContextInner {
	fn drop(&mut self) {
		let _lock = Context::make_raw_current(&self.dev, ptr::null_mut());
		unsafe { self.dev.0.alto.0.api.alcDestroyContext(self.ctx); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/al/mod.rs:712:1: 725:2'
source = '''
impl<'c> Drop for DeferLock<'c> {
	fn drop(&mut self) {
		let _ = (|| -> AltoResult<_> {
			let apus = self.0.exts.AL_SOFT_deferred_updates().and_then(|asdu| asdu.alProcessUpdatesSOFT)?;
			let old = self.0.defer_rc.fetch_sub(1, Ordering::SeqCst);
			if old == 1 {
				let _lock = self.ctx.make_current(true);
				unsafe { apus(); }
			}

			Ok(())
		})();
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/al/mod.rs:825:1: 834:2'
source = '''
impl Drop for Buffer {
	fn drop(&mut self) {
		if self.buf == 0 {
			return; 
		}

		let _lock = self.ctx.make_current(true);
		unsafe { self.ctx.0.dev.0.alto.0.api.alDeleteBuffers(1, &mut self.buf as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/al/mod.rs:1429:1: 1434:2'
source = '''
impl Drop for SourceInner {
	fn drop(&mut self) {
		let _lock = self.ctx.make_current(true);
		unsafe { self.ctx.0.dev.0.alto.0.api.alDeleteSources(1, &mut self.src as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:524:1: 537:2'
source = '''
impl Drop for AuxEffectSlot {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		for src in self.inputs.drain(..) {
			if let Some(src) = src.upgrade() {
				src.clear_aux_effect_slot(self.slot);
			}
		}

		let adaes = efx.alDeleteAuxiliaryEffectSlots.unwrap();
		unsafe { adaes(1, &mut self.slot as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1026:1: 1033:2'
source = '''
impl Drop for EaxReverbEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1318:1: 1325:2'
source = '''
impl Drop for ReverbEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1462:1: 1469:2'
source = '''
impl Drop for ChorusEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1571:1: 1578:2'
source = '''
impl Drop for DistortionEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1697:1: 1704:2'
source = '''
impl Drop for EchoEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1841:1: 1848:2'
source = '''
impl Drop for FlangerEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:1931:1: 1938:2'
source = '''
impl Drop for FrequencyShifterEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2075:1: 2082:2'
source = '''
impl Drop for VocalMorpherEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2147:1: 2154:2'
source = '''
impl Drop for PitchShifterEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2237:1: 2244:2'
source = '''
impl Drop for RingModulatorEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2345:1: 2352:2'
source = '''
impl Drop for AutowahEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2399:1: 2406:2'
source = '''
impl Drop for CompressorEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2615:1: 2622:2'
source = '''
impl Drop for EqualizerEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2672:1: 2679:2'
source = '''
impl Drop for DedicatedLowFrequencyEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2729:1: 2736:2'
source = '''
impl Drop for DedicatedDialogueEffect {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let ade = efx.alDeleteEffects.unwrap();
		unsafe { ade(1, &mut self.effect as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2815:1: 2822:2'
source = '''
impl Drop for LowpassFilter {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let adf = efx.alDeleteFilters.unwrap();
		unsafe { adf(1, &mut self.filter as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2887:1: 2894:2'
source = '''
impl Drop for HighpassFilter {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let adf = efx.alDeleteFilters.unwrap();
		unsafe { adf(1, &mut self.filter as *mut sys::ALuint); }
	}
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/efx/mod.rs:2977:1: 2984:2'
source = '''
impl Drop for BandpassFilter {
	fn drop(&mut self) {
		let efx = self.ctx.0.dev.0.exts.ALC_EXT_EFX().unwrap();
		let _lock = self.ctx.make_current(true);
		let adf = efx.alDeleteFilters.unwrap();
		unsafe { adf(1, &mut self.filter as *mut sys::ALuint); }
	}
}'''
