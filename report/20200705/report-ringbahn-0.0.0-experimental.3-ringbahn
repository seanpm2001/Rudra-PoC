[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/fs.rs:242:1: 249:2'
source = '''
impl<D: Drive> Drop for File<D> {
    fn drop(&mut self) {
        match self.active {
            Op::Nothing => unsafe { libc::close(self.fd); },
            _           => self.cancel(),
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/net/listener.rs:164:1: 171:2'
source = '''
impl<D: Drive> Drop for TcpListener<D> {
    fn drop(&mut self) {
        match self.active {
            Op::Nothing => unsafe { libc::close(self.fd); }
            _           => self.cancel(),
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/buf.rs:158:1: 166:2'
source = '''
impl Drop for Buffer {
    fn drop(&mut self) {
        if let Some(layout) = self.layout() {
            unsafe {
                dealloc(self.data.cast().as_ptr(), layout);
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/cancellation.rs:53:1: 59:2'
source = '''
impl Drop for Cancellation {
    fn drop(&mut self) {
        unsafe {
            (self.drop)(self.data, self.metadata)
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/ring.rs:112:13: 119:14'
source = '''
impl Drop for SubmissionCleaner<'_> {
                fn drop(&mut self) {
                    unsafe {
                        self.0.prep_nop();
                        self.0.set_user_data(0);
                    }
                }
            }'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/submission.rs:59:1: 66:2'
source = '''
impl<E: Event, D: Drive> Drop for Submission<E, D> {
    fn drop(&mut self) {
        if let Some(event) = &mut self.event {
            let cancellation = unsafe { Event::cancel(event) };
            self.ring.cancel(cancellation);
        }
    }
}'''
