[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/boxed.rs:79:1: 86:2'
source = '''
impl<T: ?Sized, A: Alloc> Drop for Box<T, A> {
    fn drop(&mut self) { unsafe {
        ptr::drop_in_place(self.ptr.as_ptr().as_ptr());
        if 0 != mem::size_of_val(self.deref()) {
            self.alloc.dealloc(self.ptr.as_ptr().cast(), Layout::for_value(self.ptr.as_ref()));
        }
    } }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/collections/hash_table.rs:181:1: 191:2'
source = '''
impl<K: Eq + Hash, T, H: Clone + Hasher, A: Alloc> Drop for HashTable<K, T, H, A> {
    #[inline]
    fn drop(&mut self) {
        let ptr = self.ptr;
        let log_cap = self.log_cap;
        unsafe {
            M::drop(&mut self.table);
            self.alloc.dealloc(ptr, Self::layout(log_cap).unwrap());
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/collections/raw_vec.rs:133:1: 138:2'
source = '''
impl<T, A: Alloc> Drop for RawVec<T, A> {
    #[inline]
    fn drop(&mut self) {
        unsafe { if self.cap != 0 { let _ = self.alloc.dealloc_array(self.ptr, self.cap); } }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/collections/vec.rs:315:1: 320:2'
source = '''
impl<T, A: Alloc> Drop for Vec<T, A> {
    #[inline]
    fn drop(&mut self) {
        unsafe { for p in &mut *self { ptr::drop_in_place(p); } }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/collections/vec.rs:533:1: 545:2'
source = '''
impl<'a, T: 'a, A: 'a + Alloc> Drop for Drain<'a, T, A> {
    #[inline]
    fn drop(&mut self) {
        for _ in self.by_ref() {}
        unsafe {
            let (p, q) = (self.xs.as_mut_ptr().add(self.r.start),
                          self.xs.as_mut_ptr().add(self.r.end));
            ptr::copy(q, p, self.xs.len - ptr_diff(q, self.xs.as_ptr()));
            let l = self.xs.len() - ptr_diff(q, p);
            self.xs.set_length(l);
        }
    }
}'''
