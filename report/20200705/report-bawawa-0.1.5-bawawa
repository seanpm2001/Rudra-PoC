[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/capture.rs:198:1: 220:2'
source = '''
impl<'a, C, D, R, Item> Drop for Capture<'a, C, D, R, Item>
where
    R: AsyncRead,
{
    fn drop(&mut self) {
        // it is safe to assume that the `drop` function will
        // only be called **once** and the pointer won't be
        // double freed.
        //
        // Also the pointer was created from the `Box` object
        // we only created it via Box temporarily in order
        // to safely create the pointer on the heap and to safely
        // free it from the heap.
        let boxed = unsafe { Box::from_raw(self.command) };

        unsafe {
            ManuallyDrop::drop(&mut self.framed_read);
        }

        // the `Box` is then freed and deleted from memory
        std::mem::drop(boxed);
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/send_stdin.rs:64:1: 83:2'
source = '''
impl<'a, C, E, Item> Drop for SendStdin<'a, C, E, Item> {
    fn drop(&mut self) {
        // it is safe to assume that the `drop` function will
        // only be called **once** and the pointer won't be
        // double freed.
        //
        // Also the pointer was created from the `Box` object
        // we only created it via Box temporarily in order
        // to safely create the pointer on the heap and to safely
        // free it from the heap.
        let boxed = unsafe { Box::from_raw(self.command) };

        unsafe {
            ManuallyDrop::drop(&mut self.framed_write);
        }

        // the `Box` is then freed and deleted from memory
        std::mem::drop(boxed);
    }
}'''
