[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/drc.rs:786:1: 859:2'
source = '''
impl<T> Drop for Drc<T>
where
    T: ?Sized,
{
    /// Drops the `Drc`.
    ///
    /// This will decrement the local strong reference count. In the case that
    /// this is the last `Drc` associated with the inner `Arc` (i.e. the
    /// local strong reference count reaches zero), the inner `Arc` is
    /// dropped too.
    ///
    /// A local [`Weak`] pointer may still exist, and assuming the value still
    /// persists within the `Arc`'s innards, said local `Weak` pointer might
    /// still be upgradeable even in the case that this is the last local
    /// `Drc`. In that case, the stored weak `Arc` will be upgraded to
    /// repopulate the inner `Arc`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use drc::Drc;
    ///
    /// struct Foo;
    ///
    /// impl Drop for Foo {
    ///     fn drop(&mut self) {
    ///         println!("dropped!");
    ///     }
    /// }
    ///
    /// let foo = Drc::new(Foo);
    /// let foo2 = Drc::clone(&foo);
    ///
    /// drop(foo); // Doesn't print anything
    /// drop(foo2); // Prints "dropped!"
    /// ```
    ///
    /// [`Weak`]: ./struct.Weak.html
    fn drop(&mut self) {
        unsafe {
            let strong = self.strong().get();
            self.strong().set(strong - 1);
            // In the case that this is the last strong pointer, it falls to us to
            // clean up the internal `Arc` as well as the implicit weak pointer.
            if strong == 1
            /* now it is 0 */
            {
                // Drop the contained `Arc`.
                drop(self.take_arc());

                // Clean up our implicit weak pointer.
                let weak = self.weak().get();
                self.weak().set(weak - 1);
                // In the case that that was the last weak pointer, it falls to us to
                // deallocate the `DrcInner`. If there are remaining weak pointers, they
                // can handle it themselves.
                //
                // We can not simply materialize the implicit weak pointer because it
                // will think that the implicit weak pointer is already gone due to
                // strong count being zero, and if we did not decrement strong count,
                // it wouldn't think there was any work to be done when it was dropped.
                if weak == 1
                /* now it is 0 */
                {
                    // Recreate the `Box` that the `DrcInner` was originally allocated as,
                    // so that its `Drop` implementation can run.
                    // Since we use only safe types within the `DrcInner`, this will
                    // work as expected.
                    Box::from_raw(self.ptr.as_ptr());
                }
            }
        }
    }
}'''

[[reports]]
level = 'Warning'
analyzer = 'UnsafeDestructor'
description = 'unsafe block detected in drop'
location = 'src/weak.rs:349:1: 404:2'
source = '''
impl<T> Drop for Weak<T>
where
    T: ?Sized,
{
    /// Drops the `Weak` pointer.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use drc::{Drc, Weak};
    ///
    /// struct Foo;
    ///
    /// impl Drop for Foo {
    ///     fn drop(&mut self) {
    ///         println!("dropped!");
    ///     }
    /// }
    ///
    /// let foo = Drc::new(Foo);
    /// let weak_foo = Drc::downgrade(&foo);
    /// let other_weak_foo = Weak::clone(&weak_foo);
    ///
    /// drop(weak_foo); // Doesn't print anything
    /// drop(foo); // Prints "dropped!"
    ///
    /// assert!(other_weak_foo.upgrade().is_none());
    /// ```
    fn drop(&mut self) {
        unsafe {
            let weak = self.weak().get();
            self.weak().set(weak - 1);
            if self.strong().get() == 0 {
                if weak == 1
                /* now it is 0 */
                {
                    // Recreate the `Box` that the `DrcInner` was originally allocated as,
                    // so that its `Drop` implementation can run.
                    // Since we use only safe types within the `DrcInner`, this will
                    // work as expected.
                    Box::from_raw(self.ptr.as_ptr());
                }
            } else {
                if weak == 2
                /* now it is 1 */
                {
                    // Drop the contained `WeakArc`.
                    drop(self.take_weak_arc());

                    // That's it; the remaining strong pointer(s) or a weak pointer
                    // later downgraded from a strong pointer will clean up the rest.
                }
            }
        }
    }
}'''
